1.	Understand Linked Lists:
Explain the different types of linked lists (Singly Linked List, Doubly Linked List).

Array Representation in Memory:
Contiguous Memory Allocation:
Arrays are stored in contiguous blocks of memory. This means that all elements of the array are placed next to each other in a linear sequence. This allocation allows for constant-time access to any element using an index.

Index-Based Access:
Accessing elements in an array is done through indices. For example, array[i] gives direct access to the element at position i. This results in O(1) time complexity for access operations.

Fixed Size:
Once an array is created, its size is fixed and cannot be changed. This can lead to inefficiencies if the number of elements changes frequently.

Advantages:
Efficiency: Fast access to elements due to contiguous memory allocation and direct indexing.
Simplicity: Arrays are straightforward to implement and use, making them easy to understand and manage for basic operations.

Disadvantages:
Fixed Size: Limited flexibility as the size must be defined at the time of creation.
Inserting and Deleting: Inefficient for operations that involve inserting or deleting elements since it may require shifting elements to maintain contiguous memory.

4.	Analysis:
Analyze the time complexity of each operation.
Time Complexity
Add Employee:
Time Complexity: O(1) – Adding an employee to the end of the array takes constant time, assuming there is space available. If the array is full, resizing or creating a new array (not shown in this code) would be required, which would be O(n) due to copying elements.

Search Employee:
Time Complexity: O(n) – Searching for an employee by ID involves scanning through the array linearly. In the worst case, the element is at the end of the array or not present at all, leading to a linear time complexity.

Traverse Employees:
Time Complexity: O(n) – Traversing the entire array to print details or perform operations on each employee involves visiting each element once, resulting in linear time complexity.

Delete Employee:
Time Complexity: O(n) – Finding an employee requires a linear scan, and shifting elements to fill the gap after deletion also involves linear time complexity. This is due to the need to shift all subsequent elements one position left.

Discuss the limitations of arrays and when to use them.

Fixed Size:
Limitation: Arrays have a fixed size once initialized. If the number of employees exceeds the initial capacity, the array cannot accommodate additional employees without resizing.
When to Use: Arrays are suitable when the number of elements is known beforehand and remains relatively stable, or when high-performance access and traversal are required.

Insertion and Deletion Efficiency:
Limitation: Inserting or deleting elements is inefficient due to the need to shift elements to maintain contiguous memory. This can lead to performance bottlenecks when dealing with frequent modifications.
When to Use: Arrays are effective in scenarios where modifications are rare and operations are mainly limited to accessing and traversing elements. For dynamic datasets with frequent insertions and deletions, other data structures like linked lists or dynamic arrays (e.g., ArrayList) are preferable.

Memory Utilization:
Limitation: If the allocated size of the array is significantly larger than the number of elements, memory can be wasted. Conversely, if the size is too small, resizing can be costly.
When to Use: Arrays are useful when memory constraints are known and manageable, or when working with a relatively fixed number of elements.

Lack of Flexibility:
Limitation: Arrays do not provide built-in mechanisms for dynamic resizing, complex data management, or handling of diverse operations such as concurrent modifications.
When to Use: Arrays are appropriate for simple, straightforward applications with fixed sizes and minimal modifications. For more complex scenarios, dynamic and flexible data structures are more suitable.










