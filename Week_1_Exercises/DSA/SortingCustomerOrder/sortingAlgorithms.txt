1.	Understand Sorting Algorithms:
Explain different sorting algorithms (Bubble Sort, Insertion Sort, Quick Sort, Merge Sort).
Sorting algorithms are essential for organizing data, and each algorithm has its own characteristics and use cases. Here’s an overview of some common sorting algorithms:

1. Bubble Sort
Algorithm Overview:
Bubble Sort repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. The pass through the list is repeated until no swaps are needed.

Time Complexity:
Best Case: O(n) - When the list is already sorted (optimized version).
Average Case: O(n^2) - Comparisons and swaps are made in quadratic time.
Worst Case: O(n^2) - When the list is in reverse order.

Space Complexity:
O(1) - Bubble Sort is an in-place sorting algorithm.
Use Case:
Suitable for small datasets or educational purposes due to its simplicity.

2. Insertion Sort
Algorithm Overview:
Insertion Sort builds the final sorted array one item at a time. It picks elements from the unsorted part and inserts them into the correct position in the sorted part of the array.

Time Complexity:
Best Case: O(n) - When the list is already sorted.
Average Case: O(n^2) - Requires quadratic time due to comparisons and shifts.
Worst Case: O(n^2) - When the list is in reverse order.

Space Complexity:
O(1) - Insertion Sort is also an in-place sorting algorithm.
Use Case:
Effective for small or partially sorted datasets. Often used as part of more complex algorithms.

3. Quick Sort
Algorithm Overview:
Quick Sort is a divide-and-conquer algorithm that selects a ‘pivot’ element and partitions the array into two sub-arrays, which are then sorted recursively. Elements less than the pivot go to one side, and elements greater than the pivot go to the other.

Time Complexity:
Best Case: O(n log n) - When the pivot divides the array into approximately equal halves.
Average Case: O(n log n) - Typically, Quick Sort performs well in practice.
Worst Case: O(n^2) - When the pivot is the smallest or largest element (e.g., when the array is already sorted).

Space Complexity:
O(log n) - Due to the recursion stack.
Use Case:
Quick Sort is highly efficient for large datasets and is often used in practice for its average-case performance and lower overhead.

4. Merge Sort
Algorithm Overview:
Merge Sort is a divide-and-conquer algorithm that divides the array into two halves, recursively sorts each half, and then merges the sorted halves to produce the sorted array.

Time Complexity:
Best Case: O(n log n) - The performance is consistent regardless of the initial order of elements.
Average Case: O(n log n) - Same as the best case.
Worst Case: O(n log n) - Performance remains consistent even in the worst case.

Space Complexity:
O(n) - Requires additional space for merging.
Use Case:
Ideal for large datasets and situations where stable sorting (preserving the relative order of equal elements) is required.


